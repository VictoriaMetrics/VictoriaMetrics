package promrelabel

import (
	"github.com/VictoriaMetrics/VictoriaMetrics/lib/bytesutil"
	"github.com/VictoriaMetrics/VictoriaMetrics/lib/encoding"
	"github.com/VictoriaMetrics/VictoriaMetrics/lib/slicesutil"
	"github.com/cespare/xxhash/v2"
)

const hashesCount = 2
const bitsPerItem = 16

// goldenRatio is 2^64 / Ï† (golden ratio), used for multiplicative hashing
const goldenRatio = 0x9e3779b97f4a7c15

type BloomFilter struct {
	bits []uint64
}

// Reset resets f to initial state.
//
// It is expected no other goroutines call f methods during Reset call.
func (f *BloomFilter) Reset() {
	bits := f.bits
	for i := range bits {
		bits[i] = 0
	}
}

// ContainsAll returns true if bf contains all the given tokens hashes generated by appendTokensHashes or appendHashesHashes
func (f *BloomFilter) ContainsAll(hashes []uint64) bool {
	bits := f.bits
	if len(bits) == 0 {
		return true
	}
	maxBits := uint64(len(bits)) * 64
	for _, h := range hashes {
		idx := h % maxBits
		i := idx / 64
		j := idx % 64
		mask := uint64(1) << j
		w := bits[i]
		if (w & mask) == 0 {
			// The token is missing
			return false
		}
	}
	return true
}

func (bf *BloomFilter) EnsureSize(itemCount int) {
	bitsCount := itemCount * bitsPerItem
	wordsCount := (bitsCount + 63) / 64
	if len(bf.bits) < wordsCount {
		bf.bits = slicesutil.SetLength(bf.bits, wordsCount)
	}
}

// AddTokens adds multiple tokens to the bloom filter in a batched manner.
func (bf *BloomFilter) AddTokens(tokens []string) {
	if len(bf.bits) == 0 || len(tokens) == 0 {
		return
	}

	a := encoding.GetUint64s(len(tokens) * hashesCount)
	defer encoding.PutUint64s(a)
	allHashes := a.A[:0]

	for _, token := range tokens {
		hashes := computeTokenHashes(token)
		allHashes = append(allHashes, hashes[:]...)
	}

	maxBits := uint64(len(bf.bits)) * 64
	for _, h := range allHashes {
		idx := h % maxBits
		wordIdx := idx / 64
		bitIdx := idx % 64
		mask := uint64(1) << bitIdx
		bf.bits[wordIdx] |= mask
	}
}

// AppendTokensHashes appends hashes for the given tokens to dst and returns the result.
//
// The appended hashes can be then passed to bloomFilter.containsAll().
func AppendTokensHashes(dst []uint64, tokens []string) []uint64 {
	for _, token := range tokens {
		hashes := computeTokenHashes(token)
		dst = append(dst, hashes[:]...)
	}
	return dst
}

func computeTokenHashes(token string) [hashesCount]uint64 {
	b := bytesutil.ToUnsafeBytes(token)
	h := xxhash.Sum64(b)

	// Use double hashing: h1 + i*h2
	// Second hash uses multiplicative hashing with golden ratio for good distribution at low cost
	var hashes [hashesCount]uint64
	hashes[0] = h
	hashes[1] = h * goldenRatio
	return hashes
}
